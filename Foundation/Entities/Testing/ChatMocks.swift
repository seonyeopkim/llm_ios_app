// ğŸ¤– Generated by Xcode Coding Intelligence powered by Claude Sonnet 4

import Entities

public struct ChatMocks {
    public static let `default`: [Chat] = [
        Chat(
            prompt: "What are the benefits of using SwiftUI over UIKit?",
            response: """
            # SwiftUI vs UIKit Benefits
            
            SwiftUI offers **significant advantages** over UIKit for modern iOS development:
            
            ## ğŸ¯ Key Benefits
            - **Declarative Syntax**: Write UI code that describes *what* you want, not *how* to achieve it
            - **Automatic State Management**: Built-in `@State`, `@Binding`, and `@ObservableObject` for seamless data flow
            - **Cross-Platform Compatibility**: Share code across iOS, iPadOS, macOS, watchOS, and visionOS
            - **Reduced Boilerplate**: Eliminate delegates, data sources, and complex setup code
            
            ## âš¡ Developer Experience
            - **Live Previews**: See changes instantly without rebuilding
            - **Hot Reloading**: Update UI in real-time during development  
            - **Type Safety**: Compile-time checks prevent common UI bugs
            - **Modern Swift Features**: Leverages Swift's latest capabilities like property wrappers
            
            ## ğŸ“± Performance & Maintenance
            SwiftUI provides automatic performance optimizations and makes maintaining large codebases significantly easier with its reactive architecture.
            """
        ),
        Chat(
            prompt: "How do I implement async/await in Swift?",
            response: """
            # Implementing Async/Await in Swift
            
            Swift's **async/await** provides a clean, readable approach to asynchronous programming:
            
            ## ğŸ“ Basic Syntax
            ```swift
            async func fetchData() -> Data {
                let data = await URLSession.shared.data(for: request)
                return data
            }
            ```
            
            ## ğŸ”§ Key Implementation Steps
            
            ### 1. **Function Declaration**
            - Add `async` keyword to function signature
            - Use `throws` for error-handling async functions
            
            ### 2. **Calling Async Functions**
            - Use `await` keyword before async function calls
            - Must be called from within an async context
            - Consider using `Task {}` for calling from sync contexts
            
            ### 3. **Error Handling**
            ```swift
            do {
                let result = try await networkRequest()
                // Handle success
            } catch {
                // Handle errors
            }
            ```
            
            ## âš ï¸ Important Considerations
            - **Thread Safety**: Async functions can suspend and resume on different threads
            - **Cancellation**: Use `Task.checkCancellation()` for cooperative cancellation
            - **Performance**: Avoid blocking the main thread with heavy computations
            
            ## ğŸ¯ Best Practices
            - Use `@MainActor` for UI updates
            - Leverage `TaskGroup` for concurrent operations
            - Structure async code to be cancellation-friendly
            """
        ),
        Chat(
            prompt: "What's the difference between a class and a struct in Swift?",
            response: """
            # Class vs Struct in Swift
            
            Understanding the differences between **classes** and **structs** is fundamental to Swift development:
            
            ## ğŸ—ï¸ Core Differences
            
            ### **Classes** (Reference Types)
            - **Inheritance**: Support single inheritance with `class ParentClass`
            - **Memory**: Stored on the heap, passed by reference
            - **Identity**: Can use `===` and `!==` for identity comparison
            - **Mutability**: Can modify properties even when declared as `let`
            - **Deinitialization**: Support `deinit` for cleanup when deallocated
            
            ### **Structs** (Value Types)
            - **No Inheritance**: Cannot inherit from other structs (but can conform to protocols)
            - **Memory**: Stored on the stack (when possible), passed by value
            - **Copy Semantics**: Creating a copy creates an independent instance
            - **Immutability**: `let` instances cannot have their properties modified
            - **Automatic Init**: Get memberwise initializers for free
            
            ## ğŸ“Š Memory Management
            
            | Aspect | Class | Struct |
            |--------|-------|---------|
            | Memory Location | Heap | Stack/Inline |
            | Reference Counting | ARC managed | None needed |
            | Performance | Slower allocation | Faster allocation |
            | Thread Safety | Requires synchronization | Copy-on-write safety |
            
            ## ğŸ¯ When to Use Which?
            
            ### **Use Classes When:**
            - You need inheritance and polymorphism
            - Working with Objective-C interoperability
            - Managing shared, mutable state
            - Implementing reference semantics is important
            
            ### **Use Structs When:**
            - Modeling simple data values
            - You want value semantics and immutability
            - Performance is critical (especially for small types)
            - Thread safety through copying is preferred
            
            ## ğŸ’¡ Swift's Recommendation
            **Structs are preferred** in Swift - use classes only when you specifically need reference semantics or inheritance.
            """
        ),
        Chat(
            prompt: "How can I handle errors effectively in Swift?",
            response: """
            # Effective Error Handling in Swift
            
            Swift provides **multiple robust mechanisms** for handling errors gracefully:
            
            ## ğŸ›¡ï¸ Primary Error Handling Approaches
            
            ### 1. **Do-Catch Blocks** (Recommended)
            ```swift
            do {
                let result = try riskyOperation()
                // Handle success case
            } catch NetworkError.noConnection {
                // Handle specific error
            } catch {
                // Handle any other error
            }
            ```
            
            ### 2. **Optional Try Operators**
            - **`try?`**: Returns `nil` if error occurs
            - **`try!`**: Force unwraps (use with extreme caution)
            
            ```swift
            let result = try? parseJSON(data) // Returns nil on error
            let forcedResult = try! parseJSON(validData) // Crashes on error
            ```
            
            ### 3. **Result Type** (Great for Async)
            ```swift
            enum Result<Success, Failure: Error> {
                case success(Success)
                case failure(Failure)
            }
            
            func fetchUser() -> Result<User, NetworkError> {
                // Implementation
            }
            ```
            
            ## ğŸ”§ Custom Error Types
            
            ### **Create Specific Error Enums:**
            ```swift
            enum ValidationError: Error {
                case emailInvalid
                case passwordTooShort
                case usernameExists
            }
            
            extension ValidationError: LocalizedError {
                var errorDescription: String? {
                    switch self {
                    case .emailInvalid:
                        return "Please enter a valid email address"
                    case .passwordTooShort:
                        return "Password must be at least 8 characters"
                    case .usernameExists:
                        return "Username is already taken"
                    }
                }
            }
            ```
            
            ## ğŸ“± Best Practices
            
            ### **Error Propagation**
            - Use `throws` to propagate errors up the call stack
            - Implement `rethrows` for higher-order functions
            - Consider using `async throws` for asynchronous operations
            
            ### **User Experience**
            - Always provide meaningful error messages
            - Implement proper error recovery strategies
            - Log errors appropriately for debugging
            - Show user-friendly error dialogs
            
            ### **Performance Considerations**
            - Error handling in Swift has minimal performance overhead
            - Prefer early error detection and validation
            - Use `Result` type for APIs that may fail frequently
            
            ## âš¡ Advanced Techniques
            - **Error Wrapping**: Create hierarchical error structures
            - **Error Context**: Include additional debugging information
            - **Retry Logic**: Implement automatic retry mechanisms for transient errors
            """
        ),
        Chat(
            prompt: "What are the best practices for organizing code in a Swift project?",
            response: """
            # Best Practices for Swift Project Organization
            
            Creating **well-organized, maintainable** Swift projects requires thoughtful structure and consistent practices:
            
            ## ğŸ“ Project Structure
            
            ### **Folder Organization**
            ```
            MyApp/
            â”œâ”€â”€ ğŸ“± App/
            â”‚   â”œâ”€â”€ AppDelegate.swift
            â”‚   â”œâ”€â”€ SceneDelegate.swift
            â”‚   â””â”€â”€ Info.plist
            â”œâ”€â”€ ğŸ¯ Features/
            â”‚   â”œâ”€â”€ Authentication/
            â”‚   â”œâ”€â”€ Dashboard/
            â”‚   â””â”€â”€ Settings/
            â”œâ”€â”€ ğŸ”§ Core/
            â”‚   â”œâ”€â”€ Extensions/
            â”‚   â”œâ”€â”€ Utilities/
            â”‚   â””â”€â”€ Constants/
            â”œâ”€â”€ ğŸ¨ UI/
            â”‚   â”œâ”€â”€ Components/
            â”‚   â”œâ”€â”€ Themes/
            â”‚   â””â”€â”€ Resources/
            â””â”€â”€ ğŸ“Š Data/
                â”œâ”€â”€ Models/
                â”œâ”€â”€ Services/
                â””â”€â”€ Repositories/
            ```
            
            ## ğŸ—ï¸ Architecture Patterns
            
            ### **MVVM (Recommended for SwiftUI)**
            - **Model**: Data structures and business logic
            - **View**: UI components (SwiftUI views)
            - **ViewModel**: Mediates between Model and View
            
            ### **Clean Architecture Layers**
            - **Presentation**: Views, ViewModels, Coordinators
            - **Domain**: Use cases, Entities, Repository protocols
            - **Data**: Repository implementations, Data sources
            
            ## ğŸ“ Naming Conventions
            
            ### **Files & Types**
            - **PascalCase**: `UserProfileView`, `NetworkManager`
            - **Descriptive Names**: Clearly indicate purpose and responsibility
            - **Consistent Suffixes**: `View`, `ViewModel`, `Service`, `Manager`
            
            ### **Variables & Functions**
            - **camelCase**: `userName`, `fetchUserData()`
            - **Verb-based Functions**: `validateEmail()`, `saveUserPreferences()`
            - **Boolean Prefixes**: `isLoading`, `hasError`, `canEdit`
            
            ## ğŸ”„ Code Organization Strategies
            
            ### **Extensions for Organization**
            ```swift
            // MARK: - Core Implementation
            extension UserViewModel {
                // Primary functionality
            }
            
            // MARK: - Network Operations  
            extension UserViewModel {
                // API calls and data fetching
            }
            
            // MARK: - Validation
            extension UserViewModel {
                // Input validation logic
            }
            ```
            
            ### **Protocol-Oriented Design**
            - Define clear interfaces with protocols
            - Use protocol extensions for default implementations
            - Favor composition over inheritance
            
            ## ğŸ“‹ File Organization Best Practices
            
            ### **Keep Files Focused**
            - **Single Responsibility**: One primary purpose per file
            - **Reasonable Size**: Aim for 200-400 lines maximum
            - **Logical Grouping**: Related functionality stays together
            
            ### **Import Organization**
            ```swift
            // System frameworks first
            import UIKit
            import SwiftUI
            
            // Third-party libraries
            import Alamofire
            import Kingfisher
            
            // Internal modules
            import CoreUtilities
            import NetworkLayer
            ```
            
            ## ğŸ¯ Swift API Design Guidelines
            
            ### **Follow Apple's Standards**
            - Use clear, descriptive parameter labels
            - Prefer methods that read like sentences
            - Group related functionality in the same file
            - Use `// MARK:` comments for organization
            
            ### **Consistency is Key**
            - Establish team coding standards
            - Use SwiftLint for automated style checking  
            - Regular code reviews to maintain quality
            - Document architectural decisions and patterns
            
            ## ğŸš€ Scalability Considerations
            - **Modular Design**: Break large features into smaller modules
            - **Dependency Injection**: Use protocols for testable, flexible code
            - **Feature Flags**: Implement toggleable functionality
            - **Configuration Management**: Centralize app settings and constants
            """
        ),
    ]
}
